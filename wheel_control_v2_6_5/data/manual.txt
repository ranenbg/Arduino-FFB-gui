Milos Rankovic
ranenbg@gmail.com
06.03.2025.
wheel control v2.6.4 - compatible with Arduino HEX versions fw-v250 (backward compatible with v170, v180, v190, v200, v210, v220, v230 and v240)

About:
Wheel control GUI is made in windows programming environment called Processing v3.5.4, which is based on Java. It operates by directly reading HID values from Arduino such as axis and buttons. It uses RS232 or virtual serial port to send many settings that you may like to adjust (check firmware_info.txt for more details). The settings can be stored in Arduino EEPROM, such that they will be saved and automatically loaded at every powerup. Arduino firmware and GUI are developed and tested in Win7/10/11.
You can use Arduino Leonardo, Arduino Micro or Arduino Pro Micro boards. However, hey need to have a correct bootloader. You can verify this by pressing restart button on the board. If the Arduino enters bootloader mode for about 8sec it is ok - LED will slowly blink during this time. If it instantly restarts, then you will have to upload a bootloader manually. Complete description of that procedure is outside of the scope of this manual, for details see https://www.arduino.cc/en/Tutorial/BuiltInExamples/ArduinoISP.

How to start wheel control:
[0] upload desired HEX file to your Arduino using XLoader
[1] configure the Gamepad input library (pink window)
[2] configure correct COM port for your Arduino board

There are two ways to run my wheel control program. One is by clicking on exe file for which you may need the latest version of Java to be installed on your PC. The second option is to install Processing IDE v3.5.4 on your PC and run wheel_control.pde from it. You will need to install a few missing libraries. Pay attention that wheel_control.pde with all other *.pde files must be located in the folder with the same name wheel_control. Be careful with this after downloading GUI repository from GitHub.
When 1st starting wheel control (either exe or source code), a one time configuration will be needed. A pink window will appear showing two sides of buttons and axis. You need to connect each one by dragging a line. Just start from top and work your way to the bottom. Once done, click verify button. If no errors appear click use button.
Now a dialog window will appear and you will need to select at which COM port is your Arduino, by typing one of the letters (a, b, c,...). This is required only once, since selected COM port will be saved in COM_cfg.txt file. If the number of COM devices is not changed by plugging or unplugging any other COM devices, Arduino should stay at the same COM port even after re-plug. If there was a change, go in data folder of wheel control and delete COM_cfg.txt file. Start wheel control and you will see window for selecting COM port again. File COM_cfg.txt will be saved again with new COM port. Optionally you can just manually create/edit COM_cfg.txt with a correct COM port. The COM port selection window only appears if there is no COM_cfg.txt present in data folder of wheel control. Contents of such file should be for example COM5.

How to use wheel control:
[0] set your encoder's CPR=4*PPR*GR, where GR (gear ratio) is 1 if you mounted encoder on wheel shaft
[1] set desired Rotation degrees
[2] manually align your wheel to center position, press center button and then save button
[3] select PWM type (phase correct is recommended, but you can use fast top for twice higher frequency at the same resolution)
[4] select PWM mode (pwm+-, pwm+dir, pwm0.50.100-use or rcm), you need pwm+- for BTS7960
[5] select PWM frequency (check firmware_info.txt for more details), ideally 8kHz or less.
[6] press pwm button and close wheel control, restart or re-plug Arduino to apply new PWM settings, then start wheel control again

The firmware supports user FFB effects or sometimes called desktop effects. These are "always on" effects that will be added on top of any other FFB effects which other games or application may send. You may enable certain desktop effects like spring, damper, inertia or friction by pressing a square button next to the corresponding slider. These effects may be useful for DD wheels, to simulate some realistic mechanical properties of an AC motor like moment of inertia, damping or friction.
Use general gain slider to set the master gain for all FFB effects. You may use min torque PWM slider to compensate for startup current and system friction when using other motor types than AC servo motors. It is very useful for DC brushed motors especially.
The red square button next to general gain slider is for enabling/disabling real time FFB monitor graph. It is extremely useful for troubleshooting or fine tunning your FFB settings in the game and finding the point of clipping. It is directly showing an FFB signal over COM port, that a game is sending in 1sec time window. It is recommended not to keep it always on, its purpose is only for FFB signal inspection and making sure there is no clipping. Once you are happy with your FFB level, disable the FFB monitor not to cause any potential delays due to COM data transfer.
New feature (v.2.6.0) is profile dropdown menu. Select one of the empty slots first. Make changes to the FFB settings as you wish and click store button. Type some name and click ok. This will save all firmware settings into a profile.txt file. At each startup wheel control will look for any existing profiles and load them in program memory. Once selected from drop down menu, firmware settings from that profile are  applied to Arduino within a few milliseconds. Note that PWM settings are stored in profile txt but they are not applied to Arduino upon loading. New feature (v2.6.0) is that pedal and shifter calibration are also stored/loaded in profile. If firmware doesn't support it, pressing store button will save default pedal/shifter calibration values in profile instead. After loading such a profile in GUI, pedal/shifter calibration values from it are loaded in program memory, but are not applied to Arduino (no serial commands will be sent). To prevent accidental loss of pedal or shifter calibration, always first select an empty slot in profile dropdown menu and store your current settings to be safe. However, even if you changed them in GUI, Arduino will still keep the last saved settings in its EEPROM. Those values from Arduino EEPROM are overwritten only if you press save button.

Additional startup troubleshooting has been added from v2.0, such that startup problems will be easier to diagnose. Window is no longer white, and it shows some advanced setup info. Since v2.4 I have improved the text info messages in each window from setup process, to contain some more details and to be more user friendly. Since v2.6.2 I have further improved startup diagnostics and a log txt file is created.

Axis color setup:
The axis colors are stored in a axisColor.txt file in a HEX format. This file will be created at startup with default values if it does not already exist. If it exists then the axis colors will be loaded from it. First two letters are alpha channel, so you can leave this at FF and fill in the remaining 6 numbers. In following link you can get those 6 HEX numbers from RGB values.
https://www.rapidtables.com/convert/color/rgb-to-hex.html

XY analog shifter calibration/config:
This version of wheel control allows you to setup an analog shifter. The shifter supports 8 gears + reverse, while you can edit its calibration limits by pressing "shifter" button. There are 5 pointers (sliders) that you can move with mouse by dragging. Make sure to release mouse left button while the cursor is still inside the pointer in order for change to take place. Once happy, you can click "save" button to store shifter calibration to Arduino (save values in EEPROM). There is an additional button that allows you to configure where a reverse gear will be. If the small button is red (not activated) the shifter is configured to 6 gears + reverse, while if the button is green (activated) then the reverse is in 8th gear. To activate reverse gear you need to press button0 (by default it's at Arduino pin D4, but may be elsewhere depending on firmware version and options). You may use additional shifter options available only from fw-v230f, to invert shifter X or Y axis or invert the reverse gear button (Logitech h-shifter support).

Manual pedal axis calibration:
In this version you can manual set pedal axis calibration limits and save them into Arduino EEPROM. The calibration values are automatically loaded at each powerup of Arduino. Each time you start wheel control it will ask Arduino for latest calibration values and update the sliders accordingly. In order to set calibration limits first press "man. pcal" button to unhide the calibration sliders. Move sliders to their lowest and maximum positions if they are not already there. Now push each pedal to its full range and set its corresponding maximum slider to a value slightly below the pedal axis value. Once done, now move back each pedal into there lowest position and set the minimum slider to a value slightly above the pedal axis value. Pedal axis values should move full range if done correctly. Once happy with your pedal travel and calibration limits you can press "save" button to save settings in Arduino EEPROM.

RCM pwm mode settings:
Some RC servos and other brushless motor drivers require a special pwm mode for their operation, called RCM or PPM. This version of wheel control supports the firmware version fw-v21X where I have added this new pwm mode. Note that not all frequencies are available due to the nature of this mode. A zero force is represented as a square wave with a pulse width of 1.5ms, while full left force has 1.0ms pulse width and full right force has 2.0ms pulse width. This imposes a limit for the max allowed frequency of 500Hz which corresponds to 2ms period. Any higher frequency than 500Hz would require a lower period, therefore it does not allow to achieve the full range of right (positive) forces. For that reason I have labeled such frequencies as NA - not available. I have implemented some safety features in GUI, such that you can't select or send incorrect pwm settings to firmware.

Using encoder with a Z-index:
If your encoder has a 3rd channel called Z you can use HEX firmware with "z" option to automatically detect the zero wheel angle (for this you must couple encoder to wheel shaft with exactly 1:1 ratio). Such encoders have one additional slit in their optical disc that generates Z-index pulse. Because there is just one such slit on full 360deg, we can extract an absolute angle information. It may happen that you mounted your encoder in such an orientation that its Z-index pulse does not align with real 0 wheel angle. Ideally, you want this to be somewhere near the real 0deg (but you can never perfectly match it). Since v2.6.0 of wheel control in combination with firmware v220z (and later) you can set/reset the Z-index pulse angle offset in the firmware. I will now describe the procedure. After "z" firmware upload and first start of wheel control you need to rotate your wheel/encoder until a Z-index pulse is found. When this happens, a virtual wheel in GUI will reposition to 0deg and encoder state will be set to 1 (use s key to verify). Then re-align your wheel to a real 0 angle and press center button. At that moment a new Z-index offset angle is established as a difference between previous 2 angles. Pressing the save button will save this angle offset in Arduino EEPROM. Upon each Arduino powerup, as soon as Z-index pulse has been detected this offset will be automatically applied and corrected wheel angle will be used. If you are not happy with the centering and wish to start again, you may press the z button first to reset Z-index angle offset to 0 and repeat the above described process. Tip - I use a marker to place a dot on the top side of encoder enclosure, referenced against flat portion of encoder D-shaft. This helps greatly when mounting encoder as you can keep track of Z-index angle position, such that you may orient it close to a real wheel center (within +-30 deg is typical).

Using FFB axis selector:
You can select which axis is tied to FFB with a dropdown list selector. If you select any other axis than X (encoder axis), then you can utilize analog axis as FFB input. This means that all internal and user FFB effects will also work in addition to the FFB effects that the game is sending. In that case you have to consider the rotation angle as this will depend on the sensor you use. Potentiometers normally have about 270-300deg range, while some can have more than 1 turn. If you use a hall sensor, then consider the mechanics which determine final angular range for your axis. This is only visual, it doesn't change anything, because axis range is anyway in arbitrary units as seen by the game or windows. You can set CPR to configure how much axis range you can utilize. Normally CPR of 1000 and 300deg rotation is fine for analog axis on a potentiometer. Bare in mind that manual or automatic calibration ranges for pedals (analog) axis will also have their effect on the final resolution of you analog input steering axis for FFB.

Using 2-axis FFB:
Since v2.6.3 and firmware HEX v250b and above, a feature to use 2 FFB axis is supported. This allows you to use Arduino as a flight controller where x-axis is input for xFFB and y-axis for yFFB. Correspondingly, there are 4 PWM channels configured in dual PWM+- mode for H-bridge type of DC motor drivers. First PWM channel is on D9, D10 (left, right) and 2nd PWM channel on pins D11, D5(up, down). Additionally, firmware HEX v250bd allows you to use 2 analog inputs for x- and y-axis. At the moment, x-axis analog input is selectable, while y-axis is fixed to the brake pedal input.

Hopefully everything else will be self explanatory, I believe that this is an intuitive and user friendly GUI. Enjoy :)
rane.



